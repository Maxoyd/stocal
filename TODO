- TypedReactionRule tests
- TypedReactionRule implementation
- TypedReactionRule documentation/tutorial
? signature from type annotations
=
- string rewrite rule support
- volume/temperature awareness
- non-autonomous transitions
- support for proper delay events
- libSBML integration
- statistical verification tests
- every/until filters and other stop criteria
- curried reactions (determine products only upon application)
- other kinetic laws, e.g. Hill function
- SSA profiling and algorithm variations
- C/C++/D implementation
= version 1.1+
- deprecate dict support in MassAction.reactions and ReactionRule.infer_transitions
- deprecate invalid-name arguments
= version 2


Typed Reactions
===============
ReactionRules should accept an optional signature attribute. If given,
it must evaluate to a sequence of type objects with the same length
than the arguments accepted by the Rule's novel_reactions method.
If not specified, it defaults to a sequence of `object` types whose
length equals the order of the reaction.

ReactionRule.infer_transitions can then be rewritten to only generate
combinations of reactants that adhere to the Rule's signature.
novel_reactions should be invoked for the combination reactants only
if all(isinstance(species, typ) for species, typ in
       zip(reactants, self.signature))

Alternatively, signature could be an optional keyword argument to
novel_reactants:

class MyTypedRule(stocal.ReactionRule):
    Transition = stocal.MassAction
    signature = [str, tuple]

    def novel_reactions(self, k, l):
        pass # [...]


class MyTypedRule(stocal.ReactionRule):
    Transition = stocal.MassAction

    def novel_reactions(self, k, l, signature=[str, tuple]):
        pass # [...]


At the same time, if a Rule signature is given, it should be explicitly
allowed to use variable arguments in novel_reactants, as in

class MyTypedRule(stocal.ReactionRule):
    Transition = stocal.MassAction
    signature=[str, str, str]

    def novel_reactions(self, *reactants):
        pass # [...]


Example
-------

class Complex(namedtuple('Complex', ['template', 'left', 'right'])):
    def __repr__(self):
        return '<Complex %s:%s:%s>' % (self)

class LigationRule(stocal.ReactionRule):
    """Join any two strings into their concatenations"""
    Transition = stocal.MassAction
    signature = [str, str]
    rate = 1e-3

    def novel_reactions(self, k, l):
        yield self.Transition([k, l], [k+l], self.rate)
        yield self.Transition([k, l], [l+k], self.rate)

class FirstHybridizationRule(stocal.ReactionRule):
    Transition = stocal.MassAction
    signature = [str, str]
    rate = 1e-4

    def novel_reactions(self, k, l):
		# two polymers can form a complex if the shorter polymer
		# matches the longer at either end
		if len(k)<len(l):
			k, l = l, k
		if k.startswith(l):
			yield self.Transition([k, l],
								  [Complex(k, l, None)], 2*self.rate)
		if k.endswith(l) and k!=l:
			yield self.Transition([k, l],
								  [Complex(k, None, l)], 2*self.rate)

class SecondHybridizationRule(stocal.ReactionRule):
    Transition = stocal.MassAction
    signature = [str, Complex]
    rate = 1e-4

    def novel_reactions(self, k, l):
        # if a polymer matches the free site of a complex, it can bind
        if not l.left and k+l.right == l.template:
            yield self.Transition([k, Complex(l.template, None, l.right)],
                                  [Complex(l.template, k, l.right)],
                                  self.rate)
        if not l.right and l.left+k == l.template:
            yield self.Transition([k, Complex(l.template, l.left, None)],
                                  [Complex(l.template, l.left, k)],
                                  self.rate)

